## 类的加载过程

![loading](C:\Users\wrp\Pictures\Saved Pictures\jvm\loading.png)

### 加载loading

1. 通过类的全限定类名获取类的二进制字节流
2. 字节流转化为方法区（jdk7以前称永久代、jdk8以后称元空间）的运行时数据结构
3. 在堆内存中生成一个Class对象，作为这个类的访问入口

补充：加载.class文件的方式

- 从本地文件中直接加载
- 通过网络获取
- 从zip中获取
- 动态生成（动态代理技术）
- 由其他文件生成（如JSP）
- 从专有数据库中提取.class文件（少见）
- 从加密文件中获取

### 链接 linking

#### 验证verify

作用：确保文件符合虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

#### 准备 prepare

作用：为类变量分配内存并设置默认初始值，即零值

不包括final修饰的static，final在编译的时候就会分配，准备阶段会显示初始化

不会为实例变量分配初始化，实例变量在堆中

#### 解析resolve

作用：将常量池内的 符号引用 转换为 直接引用 的过程

解析操作一般在JVM执行完初始化后执行

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。

### 初始化initialization

- 初始化阶段执行构造器方法<clinit>()过程
- <clinit>()由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
- 构造器方法中指令按语句在源文件中出现的顺序执行
- <clinit>不同于类的构造器<init>
- JVM会保证子类的<clinit>()执行前，父类的<clinit>已经执行完毕
- JVM必须保证一个类的<clinit>方法在多线程下被同步加锁（保证类只被加载一次）

## 类加载器

### JVM规范中定义的类加载器

- 引导类加载器
  - C/C++实现的，内嵌在JVM内部
  - 加载Java的核心库
  - 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
  - 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

- 自定义类加载器（派生于ClassLoader）
  - 扩展类加载器
    - java语言编写
    - 派生于ClassLoader类
    - 父类加载器为启动类加载器
    - 从java.ext.dirs系统属性所指定的目录加载类库，或从JDK的安装目录jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。
  - 应用程序类加载器
    - java语言编写
    - 派生于ClassLoader类
    - 父类加载器为扩展类加载器
    - 负责加载环境变量classpath或系统属性， java.class.path 指定的路径下的类库
    - 系统中默认的类加载器

类的继承结构：(组合方式实现，而不是使用继承)

![jvm](C:\Users\wrp\Pictures\Saved Pictures\jvm\jvm.png)

### 自定义类加载器

场景：

- 隔离加载类
- 修改类加载的方式
- 扩展资源
- 防止源码泄漏



如何实现？



### 获取ClassLoader的途径

- 方式1：clazz.getClassLoader()
- 方式2：Thread.currentThread().getContextClassLoader()
- 方式3：ClassLoader.getSystemClassLoader()
- 方式4：DriverManager.getClasserClassLoader()



## 双亲委派机制

![sq](C:\Users\wrp\Pictures\Saved Pictures\jvm\双亲委派机制.png)

优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被随意篡改

### 沙箱安全机制

？？？？





## 运行时数据区

### 栈



### 程序计数器

### 本地方法栈



### 堆

#### 核心概念

- 一个进程对应一个JVM实例，一个JVM实例有一个堆内存
- 程序启动后堆内存就分配了，其大小是可调节的
- JVM规范：堆可以物理不连续，但是逻辑上应被视为连续的
- 所有线程共享堆，堆内还可以划分线程私有的缓冲区（TLAB）
- JVM规范：所有的对象实例和数组应当在运行时分配在堆上
- 对象和数组可能永远不会存储在栈上
- 方法结束后，堆中的对象不会马上被移除，仅在垃圾收集时回收

#### 设置堆内存大小与OOM

- -Xms 设置堆的初始内存，等价于 -XX:InitialHeapSize
- -Xmx 设置堆的最大内存，等价于 -XX:MaxHeapSize
- 堆内存大于 -Xmx设置的值，则抛出OutOfMemoryError异常

说明：

- -X 是jvm的运行参数

- ms 是memory start

堆内存大小的默认值：

- 初始内存大小：**物理电脑内存大小 / 64**
- 最大内存大小：**物理电脑内存大小 / 4**

建议：

​		开发中，堆内存的初始值和最大值设置成相同的值，避免由于对内存大小动态变化影响系统的性能

查看设置的参数：

- 方式1
  - jps 查询进程id
  - jstat -gc 进程id   查看内存信息
- 方式2 -XX:+PrintGCDetails

#### 新生代与老年代

堆从逻辑上分为三部分：

- JDK7 新生代（伊甸园区、幸存者0区、幸存者1区）、老年代、永久区
- JDK8 新生代（伊甸园区、幸存者0区、幸存者1区）、老年代、元空间

堆只包括新生代和老年代

#### 对象分配过程

#### Minor GC、Major GC、Full GC

**分类**

- 部分收集
  - 新生代收集：Minor GC / Young GC 收集新生代（Eden\S0\S1）
  - 老年代收集：Major GC / Old GC 收集老年代
  - 混合收集：Mixed GC 收集整个新生代和部分老年代
    - 目前只有G1 GC有这种行为
- 整堆收集 Full GC 收集整个堆和方法区的垃圾

**触发条件**

- Minor GC 
  - Eden满时触发
  - Survivor不触发，直接晋升到老年代
  - 会引发STW
- Major GC
  - 老年代满时触发
  - 经常伴随至少一次的Minor GC （Parallel Scavenge除外）
  - 比Minor GC 慢10倍以上
  - 会引发STW
  - GC 后，内存还不够，就报OOM
- Full GC
  - 老年代空间不足
  - 方法区空间不足
  - 调用System.gc()时，系统建议执行Full GC，不是一定执行

#### 堆空间分代思想

- 为什么堆需要分代？
  - 优化GC性能，大多数对象朝生夕死

#### ==内存分配策略==

- 一般情况（对象提升Promotion规则）
  - 对象在Eden，第一次MinorGC后，进入Survivor区，年龄设置为1，当年龄到达阈值（默认15），晋升到老年区
  - -XX:MaxTenuringThreshold设置阈值
- 针对不同年龄段的对象分配原则：
  - 优先分配在Eden
  - 大对象直接分配到老年代
  - 长期存活的对象分配到老年代（超过阈值）
  - 动态对象年龄判断（Survivor区中相同年龄对象大小的总和大于Survivor区的一半，年龄大于等于该年龄的对象直接进入老年代）
  - 空间分配担保 -XX:HandlePromotionFailure

#### 为对象分配内存：TLAB

#### 小结堆空间的参数设置

- -Xms10m 堆初始大小为10m
- -Xmx10m 堆最大内存为10m
- -XX:+PrintGCDetails

#### 堆是分配对象的唯一选择吗



### 方法区

#### 存储什么

存储已被jvm加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

- 类型信息
- 静态变量
- JIT代码缓存
- 域信息
- 方法信息
- 运行时常量池 
  - class文件中的常量池（包含了各种字面量和符号引用）被类加载器加载后，放到方法区的运行时常量池中
    - 数量值
    - 字符串值
    - 类引用
    - 字段引用
    - 方法引用

```bash
将class文件反编译后输出到xxx.txt
javap -v -p xxx.class > xxx.txt
```

#### 运行时常量池

- 方法区的一部分
- JVM为每个类都维护了一个常量池，数据项用索引访问
- 与class中的常量池相比，具备动态性

#### 演进过程

- jdk6
  - 有永久代
  - 静态变量放在永久代
- JDK7
  - 有永久代
  - 字符串常量池、静态变量移入堆中
- JDK8
  - 永久代改为元空间
  - 类型信息、字段、方法、常量保存在本地内存的元空间
  - 字符串常量池、静态变量在堆中

#### 为什么移除永久代

1. 永久代空间大小有限（默认值是多少？？？），元空间依赖本地内存，GC变少
2. 永久代垃圾回收困难，调优困难（JVM规范未规定必须有GC，HotSpot**主要回收常量池中废弃的常量和不再使用的类型**）

## 对象的实例化

### 对象的实例化

创建对象的方式

- new
- Class的newInstance JDK9之后就过时了
- Constructor的newInstance(Xxx)
- 使用clone 需要实现Cloneable接口
- 使用反序列化
- 第三方库Objenesis

创建对象的步骤

1. 加载class文件
2. 分配内存
3. 处理并发安全问题
4. 默认初始化
5. 设置对象头
6. 执行init方法进行初始化（显示初始化、代码块初始化、构造器初始化）

### 对象的内存布局

- 对象头Header
  - 运行时元数据Mark Word
    - 哈希值 HashCode
    - GC分代年龄
    - 锁状态标志
    - 线程持有的锁
    - 偏向线程ID
    - 偏向时间戳
  - 类型指针->指向方法区的类元数据
  - 如果是数组，还记录了数组的长度
- 实例数据
  - 各种声明的字段，包括继承父类的字段
- 对齐填充，不是必须的

### 对象的访问定位

- 句柄访问
  - 堆中单独有个句柄池，间接引用对象和元数据，速度慢
  - GC后，Java栈不需要改变对象引用
- 直接指针（HotSpot采用）
  - 使用直接指针，速度快（待验证）
  - GC后，需要修改对象引用地址（对象存在位移）

## 直接内存

- 直接内存速度优于JVM内存（NIO举例）
- 也可能发生OOM：Direct buffer memory
- 分配回收成本高
- 不受JVM内存回收管理
- MaxDirectMemorySize设置直接内存，默认与-Xmx大小相同

简单理解：`Java Process Memory = Java Heap + Native Memory`

## 执行引擎

### 概述

- 虚拟机的执行引擎是由软件自行实现的。能够执行不被硬件直接支持的指令集格式。
- JVM主要任务： 
  - 装载字节码到JVM内部
  - 执行引擎负责将字节码指令解释、编译为本地机器的指令

### Java代码编译和执行过程

### 机器码、指令、汇编语言

### 解释器

### JIT编译器



## StringTable

> String的String pool是一个固定大小的Hashtable（数组+链表）。JDK6默认大小是1009，没有限制；JDK7默认大小是60013，JDK8开始最小值为1009。 
>
> -XX:StringTableSize可设置为StringTable的长度。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

### String特性

- 不可变性
- 字符串常量池中是不会存储相同内容的字符串的

### String常量池主要使用方法

- String str = "abc"// 字面量声明，会直接存储在常量池中
- String.intern()

### 字符串的拼接

- 常量与常量的拼接，结果在常量池，原理是编译器优化
- 常量池中不存在相同内容的常量
- 只要其中一个是变量，结果在堆中，原理是StringBuilder
- 如果拼接的结果调用intern()，将常量池中没有的字符串放入池中并返回对象地址，如果池中存在字符串，直接返回该串地址

### intern()方法

1. new String("ab"); 创建了几个对象	2个
   1. 堆中一个对象
   2. 字符串常量池中一个（jdk6：完整的"ab"；jdk7/8：池中存储的是堆对象的地址引用）
2. new String("a") + new String("b");创建了几个对象  6个
   1. 基本的4个
   2. StringBuilder
   3. toString()方法创建了一个String，但是并没有将"ab"放入池中
3. intern()方法可以节省内存空间



# GC 

## 概述

### 什么是垃圾

> 垃圾是指在运行程序中没有任何指针指向的对象。

### 为什么需要GC

- 不GC，内存迟早会消耗完
- GC可以对内存进行碎片整理，以便JVM将整理出来的内存分配给新的对象

### 自动内存管理

- 无需开发者手动参与内存的分配与回收，这样降低了 **内存泄漏和内存溢出** 的风险
- Java堆是垃圾收集器的工作重点
- 频繁收集Young区
- 较少收集Old区
- 基本不动方法区（JVM规范未规定一定要回收方法区）

## 算法

### 标记阶段：引用计数算法

> 对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。只要有其他对象引用了该对象，则引用计数器加1，当引用失效时，引用计数器减1.当为0时，该对象可以进行回收。

- 优点
  - 实现简单，垃圾便于辨识
  - 效率高，回收没有延迟性
- 缺点
  - 需要一个引用计数器，增加空间的开销
  - 每次赋值需要修改计数器，增加时间开销
  - 无法处理循环引用的情况，存在内存泄漏（导致Java垃圾回收器没有使用这类算法）

案例：python支持引用计数

怎么解决循环引用的？

- 手动解除
- 使用弱引用weakref，他是python提供的标准库



### 标记阶段：可达性分析算法

> 又叫根搜索算法、追踪性垃圾收集。

- 解决了循环引用问题，防止内存泄漏的发生

**GC Roots**包括

- java栈中引用的对象
- 本地方法栈引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁synchronized持有的对象
- JVM内部的引用 - 基本数据类型对应的Class对象等
- 反应JVM内部情况的JMXBean，JVMTI中注入的回调

还有

- 根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”加入到GC Roots中，如分代收集和局部回收

注意：

分析工作必须在一个能保障一致性的快照中进行。

- GC必须 “Stop The World”，即使是CMS，枚举根节点时也需要停顿

### 对象的finalization机制



### MAT与JProfiler的GC Roots溯源

### 清除阶段：标记-清除算法

过程

- 标记 不是垃圾的 对象
- 清除 没有被标记的对象（回收地址）

优点

- 简单

缺点

- 效率较低
- 产生内存碎片，需要维护一个空闲列表
- STW

### 清除阶段：复制算法

优点

- 速度快
- 没有内存碎片

缺点

- 浪费内存
- 如果存活对象过多，复制算法效率很低
- 需要维护对象之间的引用，浪费时间开销

### 清除阶段：标记-压缩算法

> 又称标记-整理、Mark-Compact算法。

优点

- 没有内存碎片

缺点

- 效率低于标记清除算法
- 移动对象后，需要修改对象的引用地址
- STW

### 小结

### 分代收集算法

### 增量收集算法、分区算法

## 垃圾回收相关概念

### System.gc()

> 底层是Runtime.getRuntime().gc()；会显示触发Full GC。无法保证对垃圾收集器的调用。



### 内存溢出和内存泄漏

- 内存溢出 OOM
  - 没有空闲内存，并且垃圾收集器也无法提供更多内存
  - 堆内存不够 -Xms Xmx
  - 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集
  - OOM前会触发Full GC（除了分配的超大对象，大于堆大小，直接报OOM）

- 内存泄漏
  - 对象不用了，但是GC不能回收他
  - 一些对象的生命周期被异常的延长了（局部变量改为成员变量）
  - 例子：
    - 单例程序持有堆外部对象的引用，这个外部对象是无法被回收的
    - 一些提供close的资源未关闭导致内存泄漏（数据库连接、网络连接等）

### Stop The World

> 垃圾回收时，停止所有的用户线程。

### 并发与并行

- 并发：多个事情在同一时间段内同时发生。
- 并行：多个事情在同一时刻同时发生。

### 安全点与安全区域



