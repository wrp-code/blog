## 1.分类

- 按文件类型
  - 物理备份（文件系统级别的备份）
  - 逻辑备份（备份后的文件是sql文件或特定格式的导出文件）
- 是否停止服务
  - 冷备份（备份过程中停止数据库服务）
  - 热备份（备份过程中数据库服务开启并可供用户访问）
- 是否完整
  - 全量备份(备份是完整的数据库)
  - 增量备份（备份是上一次全量备份后数据库改变的内容）







https://www.cnblogs.com/telwanggs/p/13965351.html

## 26.备份和存储

有三个完全不同的方法来备份Postgresql数据：

- SQL dump
- File system level backup 文件系统级别的备份
- Continuous archiving 连续归档

### 26.1 SQL Dump

转存方法背后的思想是创建一个有SQL命令的文件，当恢复到数据库时，重新创建和dump时相同状态的数据库。Postgresql提供了`pg_dump`来实现，基本的用法是：

```bash
pg_dump dbname > dumpfile
```

pg_dump将结果输出到一个标准的允许并行、更细粒度控制对象存储的格式的文件。

pg_dump是一个常规的Postgresql客户端程序，你可以在任何可以访问数据库的远程主机执行备份任务。特别的，他必须有所有你想要备份的表的访问权限，所以想要备份整个数据库，应该使用数据库的超级管理员去执行他。（也可以备份有访问权限的部分数据库，使用 如`-n schema`或者 `-t table`）

为了指定pg_dump要连接哪个数据库，使用命令行选项：

```bash
-h host -p port
```

默认的主机是localhost或你的`PGHOST`环境变量指定，默认的端口由`PGPORT`环境变量指定。失败的话，使用编译后的默认值。

pg_dump默认连接和操作系统用户名相同的数据库用户名，为了覆盖他，需要指定：

```bash
-U user
```

或者设置环境变量`PGUSER`。pg_dump连接遵循普通客户端的认证机制。

和其他备份方法相比，pg_dump有一个重要的优点是：pg_dump输出的文件可以被新版本的postgresql加载，但文件级备份和连续归档都是和系统相关的。pg_dump也是唯一可以在不同机器架构（32bit和64bit服务器）上工作的方法。

pg_dump创建的转储在内容是一致的，那个dump文件代表了pg_dump开始运行时数据库的快照。pg_dump工作时，不阻碍数据库上的其他操作（问题是其他的操作存在互斥锁，如很多`alter table` ）

#### 26.1.1恢复dump文件

使用`psql`命令恢复一个dump文件：

```bash
psql dbname < dumpfile
```

dbname数据库不会被这个命令创建，所以在执行psql前，应该自己创建好数据库（`createdb -T template0 dbname`）psql支持和pg_dump相似的选项来连接服务器。非文本的dump文件用`pg_restore`工具恢复。

在恢复SQLdump前，dump数据库中所有拥有对象或被授权的用户必须存在，如果不这样的话，创建对象的原生关系或权限将会失败。

默认的，psql脚本在遇到SQL错误之后将会继续执行。你可以在运行时指定`ON_ERROR_STOP`变量去改变他，在发生错误时psql退出：

```bash
psql --set ON_ERROR_STOP=on dbname < dumpfile
```

无论哪个方式，你只能有一部分恢复的数据库。另外你可以指定整个dump作为一个简单的事务被恢复，要么全部完成，要么全部回滚。这模式可以通过指定

```bash
-l
or
--single-transaction
```

命令行选项。应该注意到这个模式下，一个很小的错误也回导致一个已经执行了很多个小时的恢复被回滚。即使这样，也比部分恢复dump后手动清理一个复杂的数据库更加的可取。

pg_dump和psql从管道读写的能力使数据库从一个服务器转储到另一个服务器成为可能：

```bash
pg_dump -h host1 dbname | psql -h host2 dbname
```

重要的：

​	pg_dump转储和template0相关，意味着由template1添加的任何语言、过程等都会被pg_dump所转储,因此如果使用指定的template1恢复，你必须通过template0创建一个空数据库。

恢复备份后，明智的做法是在每个数据库上运行`ANALYZE`，这样查询优化器就有了有用的统计信息;

#### 26.1.2 使用pg_dumpall

pg_dump一次只能转储单个的数据库，他不能转储关于角色和表空间的信息（因为那些是集群范围的而不是每个数据库的），为了支持方便转储整个数据库集群的内容，提供了`pg_dumpall`，pg_dumplall备份每一个集群数据库，也保护了集群的数据如角色和表空间定义。基本的用法是：

```bash
pg_dumplall > dumpfile
```

dump结果可有用psql恢复：

```bash
psql -f dumpfile postgres
```

(实际上，你可以指定任何现有的数据库名称，但如果你加载到一个空的集群，那么通常应该使用`postgres`。)当你恢复一个pg_dumpall的dump文件时，应该有超管访问权限，因为需要恢复角色和表空间信息，如果你使用表空间，确保dump中的表空间的路径关于新安装是合适的。

pg_dumpall通过执行命令去创建新角色，表空间，和空的数据库，为每一个数据库调用pg_dump来工作。意味着每个数据库必须是内部一致的，不同的数据库的快照不应该是同步的。

集群数据可以使用pg_dumpall `--globals-only`选项独自dump，如果在个别的数据库运行pg_dump命令，对于全量备份集群是必须得。

#### 26.1.3处理大数据库

一些操作系统有文件最大值限制，当创建大pg_dump输出文件时存在问题。pg_dump可以输出标准的dump，因此你可以围绕这个潜在的问题使用标准的unix工具来工作。有几个方法：

- 使用压缩dump 你可以使用最喜欢的压缩程序，如gzip：

```bash
pg_dump dbname | gzip > filename.gz
```

加载：

```bash
gunzip -c finename.gz | psql dbname
or
cat filename.gz | gunzip | psql dbname
```

- 使用分割 `split`命令允许你分割结果为操作系统可接受的小文件：

```bash
pg_dump dbname | split -b 2G - filename
```

加载：

```bash
cat filename* | psql dbname
```

如果使用GNU分割，还可以和gzip一起使用：

```bash
pg_dump dbname | split -b 2G -- filter='gzip > $FILE.gz'
```

可以使用zcat来还原。

- 使用pg_dump的指定dump格式 如果PostgreSQL是在安装了zlib压缩库的系统上构建的，那么自定义转储格式将在将数据写入输出文件时压缩数据。这将产生与使用gzip类似的转储文件大小，但它还有一个额外的优势，即可以选择性地恢复表：

```bash
pg_dump -Fc dbname > filename
```

定制化的dump不适用于psql，而是pg_restore:

```bash
pg_restore -d dbname filename
```

对于超大的数据库，需要结合split和另外两种方法中的一个。

- 使用pg_dump的并行化dump特点 为了加速超大数据库的dump，你可以使用pg_dump的并行模式。这将同时dump多个表，你可以使用`-j`参数控制并行度，并行dump只支持那些目录归档模式

```bash
pg_dump -j num -F d -f out.dir dbname
```

你可以使用`pg_restore -j` 并行还原一个dump,这将适用于“自定义”存档模式或“目录”存档模式的任何存档，无论它是否使用`pg_dump -j`创建。

### 26.2文件级别的备份

一个可选备份策略是直接复制Postgresql使用的文件来还原数据到数据库，你可以使用任何你喜欢的方式来做文件系统备份：

```bash
tar -cf backup.tar /usr/local/pgsql/data
```

有两个限制让这个方法不实用，或者至少次于pg_dump方法：

- 为了获取一个可用的备份，数据库服务必须关闭。半路的措施如禁止所有的连接将不会生效（部分原因是tar和相似的工具不会生成院子的文件系统状态的快照，也因为服务内部的缓冲），还原数据之前，也需要关闭服务。
- 如果你深入数据库文件系统层的细节，你可以想要尝试从他们各自的文件或文件夹备份或还原个别表或数据库。这不会生效因为包含这些文件的信息没有提交日志文件`pg_xact/*`是没有用的，这个文件包含了所有事务提交的状态。一个表只用包含这些信息才是有用的。当然只还原一个表和关联的`pg_xact`数据是不可能的，因为他将造成所有在数据库集群中的其他表无效。因此文件系统备份只在完全备份和还原整个数据库集群的时候才起效。



### 26.3连续归档和时间点恢复

Postgresql一直维护了一个预写日志文件在`pg_wal`子目录的集群数据文件夹中，日志记录了数据库文件的每个改变。这个日志的存在主要是为了宕机安全目的：如果系统宕机了，数据库可以通过回放自上一个检查点来的日志条目来还原一致性。这样日志的存在让第三种备份数据库的策略成为了可能：我们可以结合文件级备份和WAL文件。如果需要恢复，我们还原文件系统备份，然后回放WAL文件备份来让系统回到目前的状态。这个方法比之前的方法更复杂，但是他也有一些重要的好处：

- 我们不需要一个完全一致的文件系统备份作为一个起始点。备份中的任何不一致可以通过日志回放来纠正（和宕机时发生的没有显著的不同）。因此我们不需要文件系统的快照功能，只要tar或者一个相似的归档工具。
- 由于我们可以结合一个无限长的WAL文件来回放，可以通过连续归档WAL文件来实现连续的备份。这个对于大数据库是非常有价值的，因为大数据库不能方便得频繁全量备份。
- 一直到头的回放WAL 条目不是必须得，我们可以在任何时间点停止回放，并拥有那个时间点数据库的连续快照。因此，这个技术也支持时间点恢复：基于你的基础备份还原数据库到他的状态是可以的。
- 如果我们不断地把WAL文件供应给另一个加载了相同的基础备份文件的机器上，我们将有一个热备份系统：我们可以在任何时间点提出第二个机器，他将拥有一个最新的数据库备份。

注意：

pg_dump和pg_dumpall没有生产文件级的备份，不能用于连续归档的解决方案。这样的dump是逻辑上的，没有包含足够的信息供WAL重放使用。

与普通的文件系统备份技术一样，这种方法只能支持恢复整个数据库集群，而不是一个子集。此外，它需要大量的归档存储:基本备份可能非常庞大，繁忙的系统将生成许多兆字节的必须归档的WAL流量。尽管如此，在许多需要高可靠性的情况下，它仍然是首选的备份技术。

为了使用连续归档成功恢复（也被许多数据库供应商称为“在线备份”)，你需要一个尽可能延伸到你备份开始时候的连续的归档WAL文件。为了开始，在你的第一个基础备份前，你应该安装并测试你的程序的归档WAL文件。

#### 26.3.1设置 WAL归档



#### 26.3.2做基础备份



#### 26.3.3使用低级别的API做基础备份



#### 26.3.4 使用连续归档备份来恢复



#### 26.3.5时间线



#### 26.3.6技巧与实例



#### 26.3.7警告

